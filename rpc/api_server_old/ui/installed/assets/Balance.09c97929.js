// import {
//   n as de,
//   d as Ke,
//   e as ga,
//   c as ve,
//   u as ha,
//   r as da,
// } from "./index.061ad1de.js";
// import {
//   P as pa,
//   e as P,
//   D as Ee,
//   r as we,
//   f as Je,
//   g as ma,
//   S as Ve,
//   h as ya,
//   j as ba,
//   k as Ge,
//   l as Se,
//   q as La,
//   m as _a,
//   n as ie,
//   T as Sa,
//   o as De,
//   B as ze,
//   p as Ye,
//   s as xa,
//   t as xe,
//   v as $,
//   w as Ca,
//   x as Ce,
//   y as Ma,
//   z as Qe,
//   A as Aa,
//   E as ue,
//   F as Ta,
//   G as wa,
//   H as Q,
//   I as Fe,
//   J as fe,
//   K as Pa,
//   L as Da,
//   M as Ia,
//   N as Pe,
//   O as ea,
//   Q as Ba,
//   R as ka,
//   _ as Ie,
//   Z as Na,
//   U as q,
//   V as Ra,
//   W as Oa,
//   X as $a,
//   Y as Ea,
//   $ as Va,
//   a0 as Ga,
//   a1 as aa,
//   a2 as za,
//   a3 as Ya,
//   a4 as Xe,
//   a5 as ta,
//   a6 as Fa,
//   a7 as Xa,
//   a8 as Ua,
//   a9 as qa,
//   aa as Ha,
//   u as ja,
//   i as Za,
//   a as Wa,
//   b as Ka,
//   c as Ja,
//   d as Qa,
//   C as et,
// } from "./install.8bbcfb1f.js";
// import { a as Ue, f as at } from "./numberformat.a1b2908a.js";
// import { c as tt } from "./createSeriesDataSimply.e9534da9.js";
// const rt = {
//   name: "EyeOffIcon",
//   emits: ["click"],
//   props: {
//     title: { type: String },
//     fillColor: { type: String, default: "currentColor" },
//     size: { type: Number, default: 24 },
//   },
// };
// var nt = function () {
//     var a = this,
//       t = a._self._c;
//     return t(
//       "span",
//       a._b(
//         {
//           staticClass: "material-design-icon eye-off-icon",
//           attrs: {
//             "aria-hidden": !a.title,
//             "aria-label": a.title,
//             role: "img",
//           },
//           on: {
//             click: function (e) {
//               return a.$emit("click", e);
//             },
//           },
//         },
//         "span",
//         a.$attrs,
//         !1
//       ),
//       [
//         t(
//           "svg",
//           {
//             staticClass: "material-design-icon__svg",
//             attrs: {
//               fill: a.fillColor,
//               width: a.size,
//               height: a.size,
//               viewBox: "0 0 24 24",
//             },
//           },
//           [
//             t(
//               "path",
//               {
//                 attrs: {
//                   d: "M11.83,9L15,12.16C15,12.11 15,12.05 15,12A3,3 0 0,0 12,9C11.94,9 11.89,9 11.83,9M7.53,9.8L9.08,11.35C9.03,11.56 9,11.77 9,12A3,3 0 0,0 12,15C12.22,15 12.44,14.97 12.65,14.92L14.2,16.47C13.53,16.8 12.79,17 12,17A5,5 0 0,1 7,12C7,11.21 7.2,10.47 7.53,9.8M2,4.27L4.28,6.55L4.73,7C3.08,8.3 1.78,10 1,12C2.73,16.39 7,19.5 12,19.5C13.55,19.5 15.03,19.2 16.38,18.66L16.81,19.08L19.73,22L21,20.73L3.27,3M12,7A5,5 0 0,1 17,12C17,12.64 16.87,13.26 16.64,13.82L19.57,16.75C21.07,15.5 22.27,13.86 23,12C21.27,7.61 17,4.5 12,4.5C10.6,4.5 9.26,4.75 8,5.2L10.17,7.35C10.74,7.13 11.35,7 12,7Z",
//                 },
//               },
//               [a.title ? t("title", [a._v(a._s(a.title))]) : a._e()]
//             ),
//           ]
//         ),
//       ]
//     );
//   },
//   it = [],
//   st = de(rt, nt, it, !1, null, null, null, null),
//   ot = st.exports;
// const lt = {
//   name: "EyeIcon",
//   emits: ["click"],
//   props: {
//     title: { type: String },
//     fillColor: { type: String, default: "currentColor" },
//     size: { type: Number, default: 24 },
//   },
// };
// var ct = function () {
//     var a = this,
//       t = a._self._c;
//     return t(
//       "span",
//       a._b(
//         {
//           staticClass: "material-design-icon eye-icon",
//           attrs: {
//             "aria-hidden": !a.title,
//             "aria-label": a.title,
//             role: "img",
//           },
//           on: {
//             click: function (e) {
//               return a.$emit("click", e);
//             },
//           },
//         },
//         "span",
//         a.$attrs,
//         !1
//       ),
//       [
//         t(
//           "svg",
//           {
//             staticClass: "material-design-icon__svg",
//             attrs: {
//               fill: a.fillColor,
//               width: a.size,
//               height: a.size,
//               viewBox: "0 0 24 24",
//             },
//           },
//           [
//             t(
//               "path",
//               {
//                 attrs: {
//                   d: "M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z",
//                 },
//               },
//               [a.title ? t("title", [a._v(a._s(a.title))]) : a._e()]
//             ),
//           ]
//         ),
//       ]
//     );
//   },
//   vt = [],
//   ut = de(lt, ct, vt, !1, null, null, null, null),
//   ft = ut.exports,
//   J = Math.PI * 2,
//   Y = pa.CMD,
//   gt = ["top", "right", "bottom", "left"];
// function ht(n, a, t, e, r) {
//   var o = t.width,
//     i = t.height;
//   switch (n) {
//     case "top":
//       e.set(t.x + o / 2, t.y - a), r.set(0, -1);
//       break;
//     case "bottom":
//       e.set(t.x + o / 2, t.y + i + a), r.set(0, 1);
//       break;
//     case "left":
//       e.set(t.x - a, t.y + i / 2), r.set(-1, 0);
//       break;
//     case "right":
//       e.set(t.x + o + a, t.y + i / 2), r.set(1, 0);
//       break;
//   }
// }
// function dt(n, a, t, e, r, o, i, l, v) {
//   (i -= n), (l -= a);
//   var u = Math.sqrt(i * i + l * l);
//   (i /= u), (l /= u);
//   var s = i * t + n,
//     d = l * t + a;
//   if (Math.abs(e - r) % J < 1e-4) return (v[0] = s), (v[1] = d), u - t;
//   if (o) {
//     var g = e;
//     (e = ie(r)), (r = ie(g));
//   } else (e = ie(e)), (r = ie(r));
//   e > r && (r += J);
//   var c = Math.atan2(l, i);
//   if ((c < 0 && (c += J), (c >= e && c <= r) || (c + J >= e && c + J <= r)))
//     return (v[0] = s), (v[1] = d), u - t;
//   var f = t * Math.cos(e) + n,
//     h = t * Math.sin(e) + a,
//     p = t * Math.cos(r) + n,
//     m = t * Math.sin(r) + a,
//     y = (f - i) * (f - i) + (h - l) * (h - l),
//     b = (p - i) * (p - i) + (m - l) * (m - l);
//   return y < b
//     ? ((v[0] = f), (v[1] = h), Math.sqrt(y))
//     : ((v[0] = p), (v[1] = m), Math.sqrt(b));
// }
// function ge(n, a, t, e, r, o, i, l) {
//   var v = r - n,
//     u = o - a,
//     s = t - n,
//     d = e - a,
//     g = Math.sqrt(s * s + d * d);
//   (s /= g), (d /= g);
//   var c = v * s + u * d,
//     f = c / g;
//   l && (f = Math.min(Math.max(f, 0), 1)), (f *= g);
//   var h = (i[0] = n + f * s),
//     p = (i[1] = a + f * d);
//   return Math.sqrt((h - r) * (h - r) + (p - o) * (p - o));
// }
// function ra(n, a, t, e, r, o, i) {
//   t < 0 && ((n = n + t), (t = -t)), e < 0 && ((a = a + e), (e = -e));
//   var l = n + t,
//     v = a + e,
//     u = (i[0] = Math.min(Math.max(r, n), l)),
//     s = (i[1] = Math.min(Math.max(o, a), v));
//   return Math.sqrt((u - r) * (u - r) + (s - o) * (s - o));
// }
// var O = [];
// function pt(n, a, t) {
//   var e = ra(a.x, a.y, a.width, a.height, n.x, n.y, O);
//   return t.set(O[0], O[1]), e;
// }
// function mt(n, a, t) {
//   for (
//     var e = 0,
//       r = 0,
//       o = 0,
//       i = 0,
//       l,
//       v,
//       u = 1 / 0,
//       s = a.data,
//       d = n.x,
//       g = n.y,
//       c = 0;
//     c < s.length;

//   ) {
//     var f = s[c++];
//     c === 1 && ((e = s[c]), (r = s[c + 1]), (o = e), (i = r));
//     var h = u;
//     switch (f) {
//       case Y.M:
//         (o = s[c++]), (i = s[c++]), (e = o), (r = i);
//         break;
//       case Y.L:
//         (h = ge(e, r, s[c], s[c + 1], d, g, O, !0)), (e = s[c++]), (r = s[c++]);
//         break;
//       case Y.C:
//         (h = _a(e, r, s[c++], s[c++], s[c++], s[c++], s[c], s[c + 1], d, g, O)),
//           (e = s[c++]),
//           (r = s[c++]);
//         break;
//       case Y.Q:
//         (h = La(e, r, s[c++], s[c++], s[c], s[c + 1], d, g, O)),
//           (e = s[c++]),
//           (r = s[c++]);
//         break;
//       case Y.A:
//         var p = s[c++],
//           m = s[c++],
//           y = s[c++],
//           b = s[c++],
//           x = s[c++],
//           S = s[c++];
//         c += 1;
//         var T = !!(1 - s[c++]);
//         (l = Math.cos(x) * y + p),
//           (v = Math.sin(x) * b + m),
//           c <= 1 && ((o = l), (i = v));
//         var M = ((d - p) * b) / y + p;
//         (h = dt(p, m, b, x, x + S, T, M, g, O)),
//           (e = Math.cos(x + S) * y + p),
//           (r = Math.sin(x + S) * b + m);
//         break;
//       case Y.R:
//         (o = e = s[c++]), (i = r = s[c++]);
//         var L = s[c++],
//           C = s[c++];
//         h = ra(o, i, L, C, d, g, O);
//         break;
//       case Y.Z:
//         (h = ge(e, r, o, i, d, g, O, !0)), (e = o), (r = i);
//         break;
//     }
//     h < u && ((u = h), t.set(O[0], O[1]));
//   }
//   return u;
// }
// var E = new P(),
//   _ = new P(),
//   A = new P(),
//   G = new P(),
//   V = new P();
// function qe(n, a) {
//   if (!!n) {
//     var t = n.getTextGuideLine(),
//       e = n.getTextContent();
//     if (!!(e && t)) {
//       var r = n.textGuideLineConfig || {},
//         o = [
//           [0, 0],
//           [0, 0],
//           [0, 0],
//         ],
//         i = r.candidates || gt,
//         l = e.getBoundingRect().clone();
//       l.applyTransform(e.getComputedTransform());
//       var v = 1 / 0,
//         u = r.anchor,
//         s = n.getComputedTransform(),
//         d = s && ya([], s),
//         g = a.get("length2") || 0;
//       u && A.copy(u);
//       for (var c = 0; c < i.length; c++) {
//         var f = i[c];
//         ht(f, 0, l, E, G), P.scaleAndAdd(_, E, G, g), _.transform(d);
//         var h = n.getBoundingRect(),
//           p = u
//             ? u.distance(_)
//             : n instanceof ba
//             ? mt(_, n.path, A)
//             : pt(_, h, A);
//         p < v &&
//           ((v = p),
//           _.transform(s),
//           A.transform(s),
//           A.toArray(o[0]),
//           _.toArray(o[1]),
//           E.toArray(o[2]));
//       }
//       na(o, a.get("minTurnAngle")), t.setShape({ points: o });
//     }
//   }
// }
// var he = [],
//   I = new P();
// function na(n, a) {
//   if (a <= 180 && a > 0) {
//     (a = (a / 180) * Math.PI),
//       E.fromArray(n[0]),
//       _.fromArray(n[1]),
//       A.fromArray(n[2]),
//       P.sub(G, E, _),
//       P.sub(V, A, _);
//     var t = G.len(),
//       e = V.len();
//     if (!(t < 0.001 || e < 0.001)) {
//       G.scale(1 / t), V.scale(1 / e);
//       var r = G.dot(V),
//         o = Math.cos(a);
//       if (o < r) {
//         var i = ge(_.x, _.y, A.x, A.y, E.x, E.y, he, !1);
//         I.fromArray(he), I.scaleAndAdd(V, i / Math.tan(Math.PI - a));
//         var l =
//           A.x !== _.x ? (I.x - _.x) / (A.x - _.x) : (I.y - _.y) / (A.y - _.y);
//         if (isNaN(l)) return;
//         l < 0 ? P.copy(I, _) : l > 1 && P.copy(I, A), I.toArray(n[1]);
//       }
//     }
//   }
// }
// function yt(n, a, t) {
//   if (t <= 180 && t > 0) {
//     (t = (t / 180) * Math.PI),
//       E.fromArray(n[0]),
//       _.fromArray(n[1]),
//       A.fromArray(n[2]),
//       P.sub(G, _, E),
//       P.sub(V, A, _);
//     var e = G.len(),
//       r = V.len();
//     if (!(e < 0.001 || r < 0.001)) {
//       G.scale(1 / e), V.scale(1 / r);
//       var o = G.dot(a),
//         i = Math.cos(t);
//       if (o < i) {
//         var l = ge(_.x, _.y, A.x, A.y, E.x, E.y, he, !1);
//         I.fromArray(he);
//         var v = Math.PI / 2,
//           u = Math.acos(V.dot(a)),
//           s = v + u - t;
//         if (s >= v) P.copy(I, A);
//         else {
//           I.scaleAndAdd(V, l / Math.tan(Math.PI / 2 - s));
//           var d =
//             A.x !== _.x ? (I.x - _.x) / (A.x - _.x) : (I.y - _.y) / (A.y - _.y);
//           if (isNaN(d)) return;
//           d < 0 ? P.copy(I, _) : d > 1 && P.copy(I, A);
//         }
//         I.toArray(n[1]);
//       }
//     }
//   }
// }
// function He(n, a, t, e) {
//   var r = t === "normal",
//     o = r ? n : n.ensureState(t);
//   o.ignore = a;
//   var i = e.get("smooth");
//   i && i === !0 && (i = 0.3),
//     (o.shape = o.shape || {}),
//     i > 0 && (o.shape.smooth = i);
//   var l = e.getModel("lineStyle").getLineStyle();
//   r ? n.useStyle(l) : (o.style = l);
// }
// function bt(n, a) {
//   var t = a.smooth,
//     e = a.points;
//   if (!!e)
//     if ((n.moveTo(e[0][0], e[0][1]), t > 0 && e.length >= 3)) {
//       var r = Ge(e[0], e[1]),
//         o = Ge(e[1], e[2]);
//       if (!r || !o) {
//         n.lineTo(e[1][0], e[1][1]), n.lineTo(e[2][0], e[2][1]);
//         return;
//       }
//       var i = Math.min(r, o) * t,
//         l = Se([], e[1], e[0], i / r),
//         v = Se([], e[1], e[2], i / o),
//         u = Se([], l, v, 0.5);
//       n.bezierCurveTo(l[0], l[1], l[0], l[1], u[0], u[1]),
//         n.bezierCurveTo(v[0], v[1], v[0], v[1], e[2][0], e[2][1]);
//     } else for (var s = 1; s < e.length; s++) n.lineTo(e[s][0], e[s][1]);
// }
// function ia(n, a, t) {
//   var e = n.getTextGuideLine(),
//     r = n.getTextContent();
//   if (!r) {
//     e && n.removeTextGuideLine();
//     return;
//   }
//   for (
//     var o = a.normal, i = o.get("show"), l = r.ignore, v = 0;
//     v < Ee.length;
//     v++
//   ) {
//     var u = Ee[v],
//       s = a[u],
//       d = u === "normal";
//     if (s) {
//       var g = s.get("show"),
//         c = d ? l : we(r.states[u] && r.states[u].ignore, l);
//       if (c || !we(g, i)) {
//         var f = d ? e : e && e.states[u];
//         f && (f.ignore = !0);
//         continue;
//       }
//       e ||
//         ((e = new Je()),
//         n.setTextGuideLine(e),
//         !d && (l || !i) && He(e, !0, "normal", a.normal),
//         n.stateProxy && (e.stateProxy = n.stateProxy)),
//         He(e, !1, u, s);
//     }
//   }
//   if (e) {
//     ma(e.style, t), (e.style.fill = null);
//     var h = o.get("showAbove"),
//       p = (n.textGuideLineConfig = n.textGuideLineConfig || {});
//     (p.showAbove = h || !1), (e.buildPath = bt);
//   }
// }
// function sa(n, a) {
//   a = a || "labelLine";
//   for (var t = { normal: n.getModel(a) }, e = 0; e < Ve.length; e++) {
//     var r = Ve[e];
//     t[r] = n.getModel([r, a]);
//   }
//   return t;
// }
// function Lt(n) {
//   if (n) {
//     for (var a = [], t = 0; t < n.length; t++) a.push(n[t].slice());
//     return a;
//   }
// }
// function _t(n, a) {
//   var t = n.label,
//     e = a && a.getTextGuideLine();
//   return {
//     dataIndex: n.dataIndex,
//     dataType: n.dataType,
//     seriesIndex: n.seriesModel.seriesIndex,
//     text: n.label.style.text,
//     rect: n.hostRect,
//     labelRect: n.rect,
//     align: t.style.align,
//     verticalAlign: t.style.verticalAlign,
//     labelLinePoints: Lt(e && e.shape.points),
//   };
// }
// var je = ["align", "verticalAlign", "width", "height", "fontSize"],
//   k = new Sa(),
//   Me = De(),
//   St = De();
// function se(n, a, t) {
//   for (var e = 0; e < t.length; e++) {
//     var r = t[e];
//     a[r] != null && (n[r] = a[r]);
//   }
// }
// var oe = ["x", "y", "rotation"],
//   xt = (function () {
//     function n() {
//       (this._labelList = []), (this._chartViewList = []);
//     }
//     return (
//       (n.prototype.clearLabels = function () {
//         (this._labelList = []), (this._chartViewList = []);
//       }),
//       (n.prototype._addLabel = function (a, t, e, r, o) {
//         var i = r.style,
//           l = r.__hostTarget,
//           v = l.textConfig || {},
//           u = r.getComputedTransform(),
//           s = r.getBoundingRect().plain();
//         ze.applyTransform(s, s, u),
//           u
//             ? k.setLocalTransform(u)
//             : ((k.x = k.y = k.rotation = k.originX = k.originY = 0),
//               (k.scaleX = k.scaleY = 1));
//         var d = r.__hostTarget,
//           g;
//         if (d) {
//           g = d.getBoundingRect().plain();
//           var c = d.getComputedTransform();
//           ze.applyTransform(g, g, c);
//         }
//         var f = g && d.getTextGuideLine();
//         this._labelList.push({
//           label: r,
//           labelLine: f,
//           seriesModel: e,
//           dataIndex: a,
//           dataType: t,
//           layoutOption: o,
//           computedLayoutOption: null,
//           rect: s,
//           hostRect: g,
//           priority: g ? g.width * g.height : 0,
//           defaultAttr: {
//             ignore: r.ignore,
//             labelGuideIgnore: f && f.ignore,
//             x: k.x,
//             y: k.y,
//             scaleX: k.scaleX,
//             scaleY: k.scaleY,
//             rotation: k.rotation,
//             style: {
//               x: i.x,
//               y: i.y,
//               align: i.align,
//               verticalAlign: i.verticalAlign,
//               width: i.width,
//               height: i.height,
//               fontSize: i.fontSize,
//             },
//             cursor: r.cursor,
//             attachedPos: v.position,
//             attachedRot: v.rotation,
//           },
//         });
//       }),
//       (n.prototype.addLabelsOfSeries = function (a) {
//         var t = this;
//         this._chartViewList.push(a);
//         var e = a.__model,
//           r = e.get("labelLayout");
//         !(Ye(r) || xa(r).length) ||
//           a.group.traverse(function (o) {
//             if (o.ignore) return !0;
//             var i = o.getTextContent(),
//               l = xe(o);
//             i &&
//               !i.disableLabelLayout &&
//               t._addLabel(l.dataIndex, l.dataType, e, i, r);
//           });
//       }),
//       (n.prototype.updateLayoutConfig = function (a) {
//         var t = a.getWidth(),
//           e = a.getHeight();
//         function r(b, x) {
//           return function () {
//             qe(b, x);
//           };
//         }
//         for (var o = 0; o < this._labelList.length; o++) {
//           var i = this._labelList[o],
//             l = i.label,
//             v = l.__hostTarget,
//             u = i.defaultAttr,
//             s = void 0;
//           Ye(i.layoutOption)
//             ? (s = i.layoutOption(_t(i, v)))
//             : (s = i.layoutOption),
//             (s = s || {}),
//             (i.computedLayoutOption = s);
//           var d = Math.PI / 180;
//           v &&
//             v.setTextConfig({
//               local: !1,
//               position: s.x != null || s.y != null ? null : u.attachedPos,
//               rotation: s.rotate != null ? s.rotate * d : u.attachedRot,
//               offset: [s.dx || 0, s.dy || 0],
//             });
//           var g = !1;
//           if (
//             (s.x != null
//               ? ((l.x = $(s.x, t)), l.setStyle("x", 0), (g = !0))
//               : ((l.x = u.x), l.setStyle("x", u.style.x)),
//             s.y != null
//               ? ((l.y = $(s.y, e)), l.setStyle("y", 0), (g = !0))
//               : ((l.y = u.y), l.setStyle("y", u.style.y)),
//             s.labelLinePoints)
//           ) {
//             var c = v.getTextGuideLine();
//             c && (c.setShape({ points: s.labelLinePoints }), (g = !1));
//           }
//           var f = Me(l);
//           (f.needsUpdateLabelLine = g),
//             (l.rotation = s.rotate != null ? s.rotate * d : u.rotation),
//             (l.scaleX = u.scaleX),
//             (l.scaleY = u.scaleY);
//           for (var h = 0; h < je.length; h++) {
//             var p = je[h];
//             l.setStyle(p, s[p] != null ? s[p] : u.style[p]);
//           }
//           if (s.draggable) {
//             if (((l.draggable = !0), (l.cursor = "move"), v)) {
//               var m = i.seriesModel;
//               if (i.dataIndex != null) {
//                 var y = i.seriesModel.getData(i.dataType);
//                 m = y.getItemModel(i.dataIndex);
//               }
//               l.on("drag", r(v, m.getModel("labelLine")));
//             }
//           } else l.off("drag"), (l.cursor = u.cursor);
//         }
//       }),
//       (n.prototype.layout = function (a) {
//         var t = a.getWidth(),
//           e = a.getHeight(),
//           r = Ca(this._labelList),
//           o = Ce(r, function (v) {
//             return v.layoutOption.moveOverlap === "shiftX";
//           }),
//           i = Ce(r, function (v) {
//             return v.layoutOption.moveOverlap === "shiftY";
//           });
//         Ma(o, 0, t), Qe(i, 0, e);
//         var l = Ce(r, function (v) {
//           return v.layoutOption.hideOverlap;
//         });
//         Aa(l);
//       }),
//       (n.prototype.processLabelsOverall = function () {
//         var a = this;
//         ue(this._chartViewList, function (t) {
//           var e = t.__model,
//             r = t.ignoreLabelLineUpdate,
//             o = e.isAnimationEnabled();
//           t.group.traverse(function (i) {
//             if (i.ignore && !i.forceLabelAnimation) return !0;
//             var l = !r,
//               v = i.getTextContent();
//             !l && v && (l = Me(v).needsUpdateLabelLine),
//               l && a._updateLabelLine(i, e),
//               o && a._animateLabels(i, e);
//           });
//         });
//       }),
//       (n.prototype._updateLabelLine = function (a, t) {
//         var e = a.getTextContent(),
//           r = xe(a),
//           o = r.dataIndex;
//         if (e && o != null) {
//           var i = t.getData(r.dataType),
//             l = i.getItemModel(o),
//             v = {},
//             u = i.getItemVisual(o, "style"),
//             s = i.getVisual("drawType");
//           v.stroke = u[s];
//           var d = l.getModel("labelLine");
//           ia(a, sa(l), v), qe(a, d);
//         }
//       }),
//       (n.prototype._animateLabels = function (a, t) {
//         var e = a.getTextContent(),
//           r = a.getTextGuideLine();
//         if (
//           e &&
//           (a.forceLabelAnimation ||
//             (!e.ignore && !e.invisible && !a.disableLabelAnimation && !Ta(a)))
//         ) {
//           var o = Me(e),
//             i = o.oldLayout,
//             l = xe(a),
//             v = l.dataIndex,
//             u = { x: e.x, y: e.y, rotation: e.rotation },
//             s = t.getData(l.dataType);
//           if (i) {
//             e.attr(i);
//             var g = a.prevStates;
//             g &&
//               (Fe(g, "select") >= 0 && e.attr(o.oldLayoutSelect),
//               Fe(g, "emphasis") >= 0 && e.attr(o.oldLayoutEmphasis)),
//               fe(e, u, t, v);
//           } else if ((e.attr(u), !wa(e).valueAnimation)) {
//             var d = we(e.style.opacity, 1);
//             (e.style.opacity = 0), Q(e, { style: { opacity: d } }, t, v);
//           }
//           if (((o.oldLayout = u), e.states.select)) {
//             var c = (o.oldLayoutSelect = {});
//             se(c, u, oe), se(c, e.states.select, oe);
//           }
//           if (e.states.emphasis) {
//             var f = (o.oldLayoutEmphasis = {});
//             se(f, u, oe), se(f, e.states.emphasis, oe);
//           }
//           Pa(e, v, s, t, t);
//         }
//         if (r && !r.ignore && !r.invisible) {
//           var o = St(r),
//             i = o.oldLayout,
//             h = { points: r.shape.points };
//           i
//             ? (r.attr({ shape: i }), fe(r, { shape: h }, t))
//             : (r.setShape(h),
//               (r.style.strokePercent = 0),
//               Q(r, { style: { strokePercent: 1 } }, t)),
//             (o.oldLayout = h);
//         }
//       }),
//       n
//     );
//   })(),
//   Ct = xt,
//   Ae = De();
// function Mt(n) {
//   n.registerUpdateLifecycle("series:beforeupdate", function (a, t, e) {
//     var r = Ae(t).labelManager;
//     r || (r = Ae(t).labelManager = new Ct()), r.clearLabels();
//   }),
//     n.registerUpdateLifecycle("series:layoutlabels", function (a, t, e) {
//       var r = Ae(t).labelManager;
//       e.updatedSeries.forEach(function (o) {
//         r.addLabelsOfSeries(t.getViewOfSeriesModel(o));
//       }),
//         r.updateLayoutConfig(t),
//         r.layout(t),
//         r.processLabelsOverall();
//     });
// }
// var le = Math.PI * 2,
//   Ze = Math.PI / 180;
// function oa(n, a) {
//   return Da(n.getBoxLayoutParams(), {
//     width: a.getWidth(),
//     height: a.getHeight(),
//   });
// }
// function la(n, a) {
//   var t = oa(n, a),
//     e = n.get("center"),
//     r = n.get("radius");
//   Pe(r) || (r = [0, r]), Pe(e) || (e = [e, e]);
//   var o = $(t.width, a.getWidth()),
//     i = $(t.height, a.getHeight()),
//     l = Math.min(o, i),
//     v = $(e[0], o) + t.x,
//     u = $(e[1], i) + t.y,
//     s = $(r[0], l / 2),
//     d = $(r[1], l / 2);
//   return { cx: v, cy: u, r0: s, r: d };
// }
// function At(n, a, t) {
//   a.eachSeriesByType(n, function (e) {
//     var r = e.getData(),
//       o = r.mapDimension("value"),
//       i = oa(e, t),
//       l = la(e, t),
//       v = l.cx,
//       u = l.cy,
//       s = l.r,
//       d = l.r0,
//       g = -e.get("startAngle") * Ze,
//       c = e.get("minAngle") * Ze,
//       f = 0;
//     r.each(o, function (D) {
//       !isNaN(D) && f++;
//     });
//     var h = r.getSum(o),
//       p = (Math.PI / (h || f)) * 2,
//       m = e.get("clockwise"),
//       y = e.get("roseType"),
//       b = e.get("stillShowZeroSum"),
//       x = r.getDataExtent(o);
//     x[0] = 0;
//     var S = le,
//       T = 0,
//       M = g,
//       L = m ? 1 : -1;
//     if (
//       (r.setLayout({ viewRect: i, r: s }),
//       r.each(o, function (D, N) {
//         var w;
//         if (isNaN(D)) {
//           r.setItemLayout(N, {
//             angle: NaN,
//             startAngle: NaN,
//             endAngle: NaN,
//             clockwise: m,
//             cx: v,
//             cy: u,
//             r0: d,
//             r: y ? NaN : s,
//           });
//           return;
//         }
//         y !== "area" ? (w = h === 0 && b ? p : D * p) : (w = le / f),
//           w < c ? ((w = c), (S -= c)) : (T += D);
//         var B = M + L * w;
//         r.setItemLayout(N, {
//           angle: w,
//           startAngle: M,
//           endAngle: B,
//           clockwise: m,
//           cx: v,
//           cy: u,
//           r0: d,
//           r: y ? Ia(D, x, [d, s]) : s,
//         }),
//           (M = B);
//       }),
//       S < le && f)
//     )
//       if (S <= 0.001) {
//         var C = le / f;
//         r.each(o, function (D, N) {
//           if (!isNaN(D)) {
//             var w = r.getItemLayout(N);
//             (w.angle = C),
//               (w.startAngle = g + L * N * C),
//               (w.endAngle = g + L * (N + 1) * C);
//           }
//         });
//       } else
//         (p = S / T),
//           (M = g),
//           r.each(o, function (D, N) {
//             if (!isNaN(D)) {
//               var w = r.getItemLayout(N),
//                 B = w.angle === c ? c : D * p;
//               (w.startAngle = M), (w.endAngle = M + L * B), (M += L * B);
//             }
//           });
//   });
// }
// function Tt(n) {
//   return {
//     seriesType: n,
//     reset: function (a, t) {
//       var e = t.findComponents({ mainType: "legend" });
//       if (!(!e || !e.length)) {
//         var r = a.getData();
//         r.filterSelf(function (o) {
//           for (var i = r.getName(o), l = 0; l < e.length; l++)
//             if (!e[l].isSelected(i)) return !1;
//           return !0;
//         });
//       }
//     },
//   };
// }
// var wt = Math.PI / 180;
// function We(n, a, t, e, r, o, i, l, v, u) {
//   if (n.length < 2) return;
//   function s(h) {
//     for (var p = h.rB, m = p * p, y = 0; y < h.list.length; y++) {
//       var b = h.list[y],
//         x = Math.abs(b.label.y - t),
//         S = e + b.len,
//         T = S * S,
//         M = Math.sqrt((1 - Math.abs((x * x) / m)) * T),
//         L = a + (M + b.len2) * r,
//         C = L - b.label.x,
//         D = b.targetTextWidth - C * r;
//       ca(b, D, !0), (b.label.x = L);
//     }
//   }
//   function d(h) {
//     for (
//       var p = { list: [], maxY: 0 }, m = { list: [], maxY: 0 }, y = 0;
//       y < h.length;
//       y++
//     )
//       if (h[y].labelAlignTo === "none") {
//         var b = h[y],
//           x = b.label.y > t ? m : p,
//           S = Math.abs(b.label.y - t);
//         if (S >= x.maxY) {
//           var T = b.label.x - a - b.len2 * r,
//             M = e + b.len,
//             L =
//               Math.abs(T) < M ? Math.sqrt((S * S) / (1 - (T * T) / M / M)) : M;
//           (x.rB = L), (x.maxY = S);
//         }
//         x.list.push(b);
//       }
//     s(p), s(m);
//   }
//   for (var g = n.length, c = 0; c < g; c++)
//     if (n[c].position === "outer" && n[c].labelAlignTo === "labelLine") {
//       var f = n[c].label.x - u;
//       (n[c].linePoints[1][0] += f), (n[c].label.x = u);
//     }
//   Qe(n, v, v + i) && d(n);
// }
// function Pt(n, a, t, e, r, o, i, l) {
//   for (
//     var v = [], u = [], s = Number.MAX_VALUE, d = -Number.MAX_VALUE, g = 0;
//     g < n.length;
//     g++
//   ) {
//     var c = n[g].label;
//     Te(n[g]) ||
//       (c.x < a
//         ? ((s = Math.min(s, c.x)), v.push(n[g]))
//         : ((d = Math.max(d, c.x)), u.push(n[g])));
//   }
//   for (var g = 0; g < n.length; g++) {
//     var f = n[g];
//     if (!Te(f) && f.linePoints) {
//       if (f.labelStyleWidth != null) continue;
//       var c = f.label,
//         h = f.linePoints,
//         p = void 0;
//       f.labelAlignTo === "edge"
//         ? c.x < a
//           ? (p = h[2][0] - f.labelDistance - i - f.edgeDistance)
//           : (p = i + r - f.edgeDistance - h[2][0] - f.labelDistance)
//         : f.labelAlignTo === "labelLine"
//         ? c.x < a
//           ? (p = s - i - f.bleedMargin)
//           : (p = i + r - d - f.bleedMargin)
//         : c.x < a
//         ? (p = c.x - i - f.bleedMargin)
//         : (p = i + r - c.x - f.bleedMargin),
//         (f.targetTextWidth = p),
//         ca(f, p);
//     }
//   }
//   We(u, a, t, e, 1, r, o, i, l, d), We(v, a, t, e, -1, r, o, i, l, s);
//   for (var g = 0; g < n.length; g++) {
//     var f = n[g];
//     if (!Te(f) && f.linePoints) {
//       var c = f.label,
//         h = f.linePoints,
//         m = f.labelAlignTo === "edge",
//         y = c.style.padding,
//         b = y ? y[1] + y[3] : 0,
//         x = c.style.backgroundColor ? 0 : b,
//         S = f.rect.width + x,
//         T = h[1][0] - h[2][0];
//       m
//         ? c.x < a
//           ? (h[2][0] = i + f.edgeDistance + S + f.labelDistance)
//           : (h[2][0] = i + r - f.edgeDistance - S - f.labelDistance)
//         : (c.x < a
//             ? (h[2][0] = c.x + f.labelDistance)
//             : (h[2][0] = c.x - f.labelDistance),
//           (h[1][0] = h[2][0] + T)),
//         (h[1][1] = h[2][1] = c.y);
//     }
//   }
// }
// function ca(n, a, t) {
//   if ((t === void 0 && (t = !1), n.labelStyleWidth == null)) {
//     var e = n.label,
//       r = e.style,
//       o = n.rect,
//       i = r.backgroundColor,
//       l = r.padding,
//       v = l ? l[1] + l[3] : 0,
//       u = r.overflow,
//       s = o.width + (i ? 0 : v);
//     if (a < s || t) {
//       var d = o.height;
//       if (u && u.match("break")) {
//         e.setStyle("backgroundColor", null), e.setStyle("width", a - v);
//         var g = e.getBoundingRect();
//         e.setStyle("width", Math.ceil(g.width)),
//           e.setStyle("backgroundColor", i);
//       } else {
//         var c = a - v,
//           f = a < s ? c : t ? (c > n.unconstrainedWidth ? null : c) : null;
//         e.setStyle("width", f);
//       }
//       var h = e.getBoundingRect();
//       o.width = h.width;
//       var p = (e.style.margin || 0) + 2.1;
//       (o.height = h.height + p), (o.y -= (o.height - d) / 2);
//     }
//   }
// }
// function Te(n) {
//   return n.position === "center";
// }
// function Dt(n) {
//   var a = n.getData(),
//     t = [],
//     e,
//     r,
//     o = !1,
//     i = (n.get("minShowLabelAngle") || 0) * wt,
//     l = a.getLayout("viewRect"),
//     v = a.getLayout("r"),
//     u = l.width,
//     s = l.x,
//     d = l.y,
//     g = l.height;
//   function c(T) {
//     T.ignore = !0;
//   }
//   function f(T) {
//     if (!T.ignore) return !0;
//     for (var M in T.states) if (T.states[M].ignore === !1) return !0;
//     return !1;
//   }
//   a.each(function (T) {
//     var M = a.getItemGraphicEl(T),
//       L = M.shape,
//       C = M.getTextContent(),
//       D = M.getTextGuideLine(),
//       N = a.getItemModel(T),
//       w = N.getModel("label"),
//       B = w.get("position") || N.get(["emphasis", "label", "position"]),
//       pe = w.get("distanceToLabelLine"),
//       me = w.get("alignTo"),
//       ye = $(w.get("edgeDistance"), u),
//       va = w.get("bleedMargin"),
//       ee = N.getModel("labelLine"),
//       H = ee.get("length");
//     H = $(H, u);
//     var ae = ee.get("length2");
//     if (((ae = $(ae, u)), Math.abs(L.endAngle - L.startAngle) < i)) {
//       ue(C.states, c), (C.ignore = !0);
//       return;
//     }
//     if (!!f(C)) {
//       var te = (L.startAngle + L.endAngle) / 2,
//         R = Math.cos(te),
//         z = Math.sin(te),
//         j,
//         re,
//         Be,
//         ne;
//       (e = L.cx), (r = L.cy);
//       var F = B === "inside" || B === "inner";
//       if (B === "center") (j = L.cx), (re = L.cy), (ne = "center");
//       else {
//         var be = (F ? ((L.r + L.r0) / 2) * R : L.r * R) + e,
//           Le = (F ? ((L.r + L.r0) / 2) * z : L.r * z) + r;
//         if (((j = be + R * 3), (re = Le + z * 3), !F)) {
//           var ke = be + R * (H + v - L.r),
//             Ne = Le + z * (H + v - L.r),
//             Re = ke + (R < 0 ? -1 : 1) * ae,
//             Oe = Ne;
//           me === "edge"
//             ? (j = R < 0 ? s + ye : s + u - ye)
//             : (j = Re + (R < 0 ? -pe : pe)),
//             (re = Oe),
//             (Be = [
//               [be, Le],
//               [ke, Ne],
//               [Re, Oe],
//             ]);
//         }
//         ne = F
//           ? "center"
//           : me === "edge"
//           ? R > 0
//             ? "right"
//             : "left"
//           : R > 0
//           ? "left"
//           : "right";
//       }
//       var Z = Math.PI,
//         X = 0,
//         W = w.get("rotate");
//       if (ea(W)) X = W * (Z / 180);
//       else if (B === "center") X = 0;
//       else if (W === "radial" || W === !0) {
//         var ua = R < 0 ? -te + Z : -te;
//         X = ua;
//       } else if (W === "tangential" && B !== "outside" && B !== "outer") {
//         var U = Math.atan2(R, z);
//         U < 0 && (U = Z * 2 + U);
//         var fa = z > 0;
//         fa && (U = Z + U), (X = U - Z);
//       }
//       if (
//         ((o = !!X),
//         (C.x = j),
//         (C.y = re),
//         (C.rotation = X),
//         C.setStyle({ verticalAlign: "middle" }),
//         F)
//       ) {
//         C.setStyle({ align: ne });
//         var _e = C.states.select;
//         _e && ((_e.x += C.x), (_e.y += C.y));
//       } else {
//         var K = C.getBoundingRect().clone();
//         K.applyTransform(C.getComputedTransform());
//         var $e = (C.style.margin || 0) + 2.1;
//         (K.y -= $e / 2),
//           (K.height += $e),
//           t.push({
//             label: C,
//             labelLine: D,
//             position: B,
//             len: H,
//             len2: ae,
//             minTurnAngle: ee.get("minTurnAngle"),
//             maxSurfaceAngle: ee.get("maxSurfaceAngle"),
//             surfaceNormal: new P(R, z),
//             linePoints: Be,
//             textAlign: ne,
//             labelDistance: pe,
//             labelAlignTo: me,
//             edgeDistance: ye,
//             bleedMargin: va,
//             rect: K,
//             unconstrainedWidth: K.width,
//             labelStyleWidth: C.style.width,
//           });
//       }
//       M.setTextConfig({ inside: F });
//     }
//   }),
//     !o && n.get("avoidLabelOverlap") && Pt(t, e, r, v, u, g, s, d);
//   for (var h = 0; h < t.length; h++) {
//     var p = t[h],
//       m = p.label,
//       y = p.labelLine,
//       b = isNaN(m.x) || isNaN(m.y);
//     if (m) {
//       m.setStyle({ align: p.textAlign }),
//         b && (ue(m.states, c), (m.ignore = !0));
//       var x = m.states.select;
//       x && ((x.x += m.x), (x.y += m.y));
//     }
//     if (y) {
//       var S = p.linePoints;
//       b || !S
//         ? (ue(y.states, c), (y.ignore = !0))
//         : (na(S, p.minTurnAngle),
//           yt(S, p.surfaceNormal, p.maxSurfaceAngle),
//           y.setShape({ points: S }),
//           (m.__hostTarget.textGuideLineConfig = {
//             anchor: new P(S[0][0], S[0][1]),
//           }));
//     }
//   }
// }
// function ce(n, a, t) {
//   var e = n.get("borderRadius");
//   if (e == null) return t ? { cornerRadius: 0 } : null;
//   Pe(e) || (e = [e, e, e, e]);
//   var r = Math.abs(a.r || 0 - a.r0 || 0);
//   return {
//     cornerRadius: Ba(e, function (o) {
//       return ka(o, r);
//     }),
//   };
// }
// var It = (function (n) {
//     Ie(a, n);
//     function a(t, e, r) {
//       var o = n.call(this) || this;
//       o.z2 = 2;
//       var i = new Na();
//       return o.setTextContent(i), o.updateData(t, e, r, !0), o;
//     }
//     return (
//       (a.prototype.updateData = function (t, e, r, o) {
//         var i = this,
//           l = t.hostModel,
//           v = t.getItemModel(e),
//           u = v.getModel("emphasis"),
//           s = t.getItemLayout(e),
//           d = q(ce(v.getModel("itemStyle"), s, !0), s);
//         if (isNaN(d.startAngle)) {
//           i.setShape(d);
//           return;
//         }
//         if (o) {
//           i.setShape(d);
//           var g = l.getShallow("animationType");
//           l.ecModel.ssr
//             ? (Q(i, { scaleX: 0, scaleY: 0 }, l, { dataIndex: e, isFrom: !0 }),
//               (i.originX = d.cx),
//               (i.originY = d.cy))
//             : g === "scale"
//             ? ((i.shape.r = s.r0), Q(i, { shape: { r: s.r } }, l, e))
//             : r != null
//             ? (i.setShape({ startAngle: r, endAngle: r }),
//               Q(
//                 i,
//                 { shape: { startAngle: s.startAngle, endAngle: s.endAngle } },
//                 l,
//                 e
//               ))
//             : ((i.shape.endAngle = s.startAngle),
//               fe(i, { shape: { endAngle: s.endAngle } }, l, e));
//         } else Ra(i), fe(i, { shape: d }, l, e);
//         i.useStyle(t.getItemVisual(e, "style")), Oa(i, v);
//         var c = (s.startAngle + s.endAngle) / 2,
//           f = l.get("selectedOffset"),
//           h = Math.cos(c) * f,
//           p = Math.sin(c) * f,
//           m = v.getShallow("cursor");
//         m && i.attr("cursor", m),
//           this._updateLabel(l, t, e),
//           (i.ensureState("emphasis").shape = q(
//             { r: s.r + ((u.get("scale") && u.get("scaleSize")) || 0) },
//             ce(u.getModel("itemStyle"), s)
//           )),
//           q(i.ensureState("select"), {
//             x: h,
//             y: p,
//             shape: ce(v.getModel(["select", "itemStyle"]), s),
//           }),
//           q(i.ensureState("blur"), {
//             shape: ce(v.getModel(["blur", "itemStyle"]), s),
//           });
//         var y = i.getTextGuideLine(),
//           b = i.getTextContent();
//         y && q(y.ensureState("select"), { x: h, y: p }),
//           q(b.ensureState("select"), { x: h, y: p }),
//           $a(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
//       }),
//       (a.prototype._updateLabel = function (t, e, r) {
//         var o = this,
//           i = e.getItemModel(r),
//           l = i.getModel("labelLine"),
//           v = e.getItemVisual(r, "style"),
//           u = v && v.fill,
//           s = v && v.opacity;
//         Ea(o, Va(i), {
//           labelFetcher: e.hostModel,
//           labelDataIndex: r,
//           inheritColor: u,
//           defaultOpacity: s,
//           defaultText: t.getFormattedLabel(r, "normal") || e.getName(r),
//         });
//         var d = o.getTextContent();
//         o.setTextConfig({ position: null, rotation: null }), d.attr({ z2: 10 });
//         var g = t.get(["label", "position"]);
//         if (g !== "outside" && g !== "outer") o.removeTextGuideLine();
//         else {
//           var c = this.getTextGuideLine();
//           c || ((c = new Je()), this.setTextGuideLine(c)),
//             ia(this, sa(i), {
//               stroke: u,
//               opacity: Ga(l.get(["lineStyle", "opacity"]), s, 1),
//             });
//         }
//       }),
//       a
//     );
//   })(aa),
//   Bt = (function (n) {
//     Ie(a, n);
//     function a() {
//       var t = (n !== null && n.apply(this, arguments)) || this;
//       return (t.ignoreLabelLineUpdate = !0), t;
//     }
//     return (
//       (a.prototype.render = function (t, e, r, o) {
//         var i = t.getData(),
//           l = this._data,
//           v = this.group,
//           u;
//         if (!l && i.count() > 0) {
//           for (
//             var s = i.getItemLayout(0), d = 1;
//             isNaN(s && s.startAngle) && d < i.count();
//             ++d
//           )
//             s = i.getItemLayout(d);
//           s && (u = s.startAngle);
//         }
//         if (
//           (this._emptyCircleSector && v.remove(this._emptyCircleSector),
//           i.count() === 0 && t.get("showEmptyCircle"))
//         ) {
//           var g = new aa({ shape: la(t, r) });
//           g.useStyle(t.getModel("emptyCircleStyle").getItemStyle()),
//             (this._emptyCircleSector = g),
//             v.add(g);
//         }
//         i
//           .diff(l)
//           .add(function (c) {
//             var f = new It(i, c, u);
//             i.setItemGraphicEl(c, f), v.add(f);
//           })
//           .update(function (c, f) {
//             var h = l.getItemGraphicEl(f);
//             h.updateData(i, c, u),
//               h.off("click"),
//               v.add(h),
//               i.setItemGraphicEl(c, h);
//           })
//           .remove(function (c) {
//             var f = l.getItemGraphicEl(c);
//             za(f, t, c);
//           })
//           .execute(),
//           Dt(t),
//           t.get("animationTypeUpdate") !== "expansion" && (this._data = i);
//       }),
//       (a.prototype.dispose = function () {}),
//       (a.prototype.containPoint = function (t, e) {
//         var r = e.getData(),
//           o = r.getItemLayout(0);
//         if (o) {
//           var i = t[0] - o.cx,
//             l = t[1] - o.cy,
//             v = Math.sqrt(i * i + l * l);
//           return v <= o.r && v >= o.r0;
//         }
//       }),
//       (a.type = "pie"),
//       a
//     );
//   })(Ya),
//   kt = Bt,
//   Nt = (function () {
//     function n(a, t) {
//       (this._getDataWithEncodedVisual = a), (this._getRawData = t);
//     }
//     return (
//       (n.prototype.getAllNames = function () {
//         var a = this._getRawData();
//         return a.mapArray(a.getName);
//       }),
//       (n.prototype.containName = function (a) {
//         var t = this._getRawData();
//         return t.indexOfName(a) >= 0;
//       }),
//       (n.prototype.indexOfName = function (a) {
//         var t = this._getDataWithEncodedVisual();
//         return t.indexOfName(a);
//       }),
//       (n.prototype.getItemVisual = function (a, t) {
//         var e = this._getDataWithEncodedVisual();
//         return e.getItemVisual(a, t);
//       }),
//       n
//     );
//   })(),
//   Rt = Nt,
//   Ot = (function (n) {
//     Ie(a, n);
//     function a() {
//       return (n !== null && n.apply(this, arguments)) || this;
//     }
//     return (
//       (a.prototype.init = function (t) {
//         n.prototype.init.apply(this, arguments),
//           (this.legendVisualProvider = new Rt(
//             Xe(this.getData, this),
//             Xe(this.getRawData, this)
//           )),
//           this._defaultLabelLine(t);
//       }),
//       (a.prototype.mergeOption = function () {
//         n.prototype.mergeOption.apply(this, arguments);
//       }),
//       (a.prototype.getInitialData = function () {
//         return tt(this, {
//           coordDimensions: ["value"],
//           encodeDefaulter: ta(Fa, this),
//         });
//       }),
//       (a.prototype.getDataParams = function (t) {
//         var e = this.getData(),
//           r = n.prototype.getDataParams.call(this, t),
//           o = [];
//         return (
//           e.each(e.mapDimension("value"), function (i) {
//             o.push(i);
//           }),
//           (r.percent = Xa(o, t, e.hostModel.get("percentPrecision"))),
//           r.$vars.push("percent"),
//           r
//         );
//       }),
//       (a.prototype._defaultLabelLine = function (t) {
//         Ua(t, "labelLine", ["show"]);
//         var e = t.labelLine,
//           r = t.emphasis.labelLine;
//         (e.show = e.show && t.label.show),
//           (r.show = r.show && t.emphasis.label.show);
//       }),
//       (a.type = "series.pie"),
//       (a.defaultOption = {
//         z: 2,
//         legendHoverLink: !0,
//         colorBy: "data",
//         center: ["50%", "50%"],
//         radius: [0, "75%"],
//         clockwise: !0,
//         startAngle: 90,
//         minAngle: 0,
//         minShowLabelAngle: 0,
//         selectedOffset: 10,
//         percentPrecision: 2,
//         stillShowZeroSum: !0,
//         left: 0,
//         top: 0,
//         right: 0,
//         bottom: 0,
//         width: null,
//         height: null,
//         label: {
//           rotate: 0,
//           show: !0,
//           overflow: "truncate",
//           position: "outer",
//           alignTo: "none",
//           edgeDistance: "25%",
//           bleedMargin: 10,
//           distanceToLabelLine: 5,
//         },
//         labelLine: {
//           show: !0,
//           length: 15,
//           length2: 15,
//           smooth: !1,
//           minTurnAngle: 90,
//           maxSurfaceAngle: 90,
//           lineStyle: { width: 1, type: "solid" },
//         },
//         itemStyle: { borderWidth: 1, borderJoin: "round" },
//         showEmptyCircle: !0,
//         emptyCircleStyle: { color: "lightgray", opacity: 1 },
//         labelLayout: { hideOverlap: !0 },
//         emphasis: { scale: !0, scaleSize: 5 },
//         avoidLabelOverlap: !0,
//         animationType: "expansion",
//         animationDuration: 1e3,
//         animationTypeUpdate: "transition",
//         animationEasingUpdate: "cubicInOut",
//         animationDurationUpdate: 500,
//         animationEasing: "cubicInOut",
//       }),
//       a
//     );
//   })(qa),
//   $t = Ot;
// function Et(n) {
//   return {
//     seriesType: n,
//     reset: function (a, t) {
//       var e = a.getData();
//       e.filterSelf(function (r) {
//         var o = e.mapDimension("value"),
//           i = e.get(o, r);
//         return !(ea(i) && !isNaN(i) && i < 0);
//       });
//     },
//   };
// }
// function Vt(n) {
//   n.registerChartView(kt),
//     n.registerSeriesModel($t),
//     Ha("pie", n.registerAction),
//     n.registerLayout(ta(At, "pie")),
//     n.registerProcessor(Tt("pie")),
//     n.registerProcessor(Et("pie"));
// }
// ja([Vt, Za, Wa, Ka, Ja, Qa, Mt]);
// var Gt = Ke({
//   name: "BalanceChart",
//   components: { "v-chart": et },
//   props: {
//     currencies: { required: !0, type: Array },
//     showTitle: { required: !1, type: Boolean },
//   },
//   setup(n) {
//     const a = ga();
//     return {
//       balanceChartOptions: ve(() => ({
//         title: { text: "Balance", show: n.showTitle },
//         center: ["50%", "50%"],
//         backgroundColor: "rgba(0, 0, 0, 0)",
//         dataset: {
//           dimensions: [
//             "balance",
//             "currency",
//             "est_stake",
//             "free",
//             "used",
//             "stake",
//           ],
//           source: n.currencies,
//         },
//         tooltip: {
//           trigger: "item",
//           formatter: (e) =>
//             `${Ue(e.value.balance, e.value.currency, 8)}<br />${
//               e.percent
//             }% (${Ue(e.value.est_stake, e.value.stake)})`,
//         },
//         series: [
//           {
//             type: "pie",
//             radius: ["40%", "70%"],
//             encode: {
//               value: "est_stake",
//               itemName: "currency",
//               tooltip: ["balance", "currency"],
//             },
//             label: { formatter: "{b} - {d}%" },
//             tooltip: { show: !0 },
//           },
//         ],
//       })),
//       settingsStore: a,
//     };
//   },
// });
// var zt = function () {
//     var a = this,
//       t = a._self._c;
//     return (
//       a._self._setupProxy,
//       a.currencies
//         ? t("v-chart", {
//             attrs: {
//               option: a.balanceChartOptions,
//               theme: a.settingsStore.chartTheme,
//               autoresize: "",
//             },
//           })
//         : a._e()
//     );
//   },
//   Yt = [],
//   Ft = de(Gt, zt, Yt, !1, null, "ee06b227", null, null),
//   Xt = Ft.exports,
//   Ut = Ke({
//     name: "Balance",
//     components: { HideIcon: ot, ShowIcon: ft, BalanceChart: Xt },
//     setup() {
//       const n = ha(),
//         a = da(!0),
//         t = ve(() =>
//           Number((0.1 ** n.activeBot.stakeCurrencyDecimals).toFixed(8))
//         ),
//         e = ve(() => {
//           var i;
//           return a.value
//             ? (i = n.activeBot.balance.currencies) == null
//               ? void 0
//               : i.filter((l) => l.est_stake >= t.value)
//             : n.activeBot.balance.currencies;
//         }),
//         r = ve(() => [
//           { key: "currency", label: "Currency" },
//           { key: "free", label: "Available", formatter: "formatCurrency" },
//           {
//             key: "est_stake",
//             label: `in ${n.activeBot.balance.stake}`,
//             formatter: "formatCurrency",
//           },
//         ]);
//       return {
//         botStore: n,
//         hideSmallBalances: a,
//         formatPercent: at,
//         smallBalance: t,
//         balanceCurrencies: e,
//         tableFields: r,
//         formatCurrency: (i) => (i ? i.toFixed(5) : ""),
//       };
//     },
//   }),
//   qt = function () {
//     var a = this,
//       t = a._self._c;
//     return (
//       a._self._setupProxy,
//       t(
//         "div",
//         [
//           t(
//             "div",
//             { staticClass: "mb-2" },
//             [
//               t("label", { staticClass: "mr-auto h3" }, [a._v("Balance")]),
//               t(
//                 "b-button",
//                 {
//                   staticClass: "float-right",
//                   attrs: { size: "sm" },
//                   on: { click: a.botStore.activeBot.getBalance },
//                 },
//                 [a._v("\u21BB")]
//               ),
//               t(
//                 "b-form-checkbox",
//                 {
//                   staticClass: "float-right",
//                   attrs: {
//                     size: "sm",
//                     title: "Hide small balances",
//                     button: "",
//                   },
//                   model: {
//                     value: a.hideSmallBalances,
//                     callback: function (e) {
//                       a.hideSmallBalances = e;
//                     },
//                     expression: "hideSmallBalances",
//                   },
//                 },
//                 [
//                   a.hideSmallBalances
//                     ? t("HideIcon", { attrs: { size: 16 } })
//                     : t("ShowIcon", { attrs: { size: 16 } }),
//                 ],
//                 1
//               ),
//             ],
//             1
//           ),
//           a.balanceCurrencies
//             ? t("BalanceChart", { attrs: { currencies: a.balanceCurrencies } })
//             : a._e(),
//           t(
//             "div",
//             [
//               a.botStore.activeBot.balance.note
//                 ? t("p", [
//                     t("strong", [
//                       a._v(a._s(a.botStore.activeBot.balance.note)),
//                     ]),
//                   ])
//                 : a._e(),
//               t(
//                 "b-table",
//                 {
//                   staticClass: "table-sm",
//                   attrs: { items: a.balanceCurrencies, fields: a.tableFields },
//                 },
//                 [
//                   t("template", { slot: "bottom-row" }, [
//                     t("td", [t("strong", [a._v("Total")])]),
//                     t("td", [
//                       t(
//                         "span",
//                         {
//                           staticClass: "font-italic",
//                           attrs: {
//                             title: `Increase over initial capital of ${a.formatCurrency(
//                               a.botStore.activeBot.balance.starting_capital
//                             )} ${a.botStore.activeBot.balance.stake}`,
//                           },
//                         },
//                         [
//                           a._v(
//                             a._s(
//                               a.formatPercent(
//                                 a.botStore.activeBot.balance
//                                   .starting_capital_ratio
//                               )
//                             )
//                           ),
//                         ]
//                       ),
//                     ]),
//                     t("td", [
//                       t("strong", [
//                         a._v(
//                           a._s(
//                             a.formatCurrency(a.botStore.activeBot.balance.total)
//                           )
//                         ),
//                       ]),
//                     ]),
//                   ]),
//                 ],
//                 2
//               ),
//             ],
//             1
//           ),
//         ],
//         1
//       )
//     );
//   },
//   Ht = [],
//   jt = de(Ut, qt, Ht, !1, null, null, null, null),
//   Qt = jt.exports;
// export { Qt as default };
// //# sourceMappingURL=Balance.09c97929.js.map
